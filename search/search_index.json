{
    "docs": [
        {
            "location": "/",
            "text": "Multiway Algorithms\n\n\nJava library of multi-way algorithms.\n\n\nAlgorithms\n\n\nAvailable algorithms:\n\n\n\n\nPARAFAC\n\n\nMulti-way PLS\n\n\n\n\nPlanned:\n\n\n\n\nNon-negative Matrix Factorization (NMF)\n\n\nMultivariate Filtering\n\n\n\n\nMaven\n\n\nAdd the following dependency in your \npom.xml\n:\n\n\n   <dependency>\n     <groupId>nz.ac.waikato.cms.adams</groupId>\n     <artifactId>multiway-algorithms</artifactId>\n     <version>0.0.3</version>\n   </dependency>",
            "title": "Home"
        },
        {
            "location": "/#multiway-algorithms",
            "text": "Java library of multi-way algorithms.",
            "title": "Multiway Algorithms"
        },
        {
            "location": "/#algorithms",
            "text": "Available algorithms:   PARAFAC  Multi-way PLS   Planned:   Non-negative Matrix Factorization (NMF)  Multivariate Filtering",
            "title": "Algorithms"
        },
        {
            "location": "/#maven",
            "text": "Add the following dependency in your  pom.xml :     <dependency>\n     <groupId>nz.ac.waikato.cms.adams</groupId>\n     <artifactId>multiway-algorithms</artifactId>\n     <version>0.0.3</version>\n   </dependency>",
            "title": "Maven"
        },
        {
            "location": "/algorithms/parafac/",
            "text": "The PARAFAC Model\n\n\nPARAFAC\n allows the decomposition of three-way data into three loading matrices. \n\n\nParameters\n\n\n\n\n\n\n\n\nParameter Name\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnumComponents\n\n\n3\n\n\nNumber of components of the loading matrices.\n\n\n\n\n\n\nnumStarts\n\n\n1\n\n\nNumber of restarts to find a better minimum. This is only effective if \ninitMethod=RANDOM\n.\n\n\n\n\n\n\ninitMethod\n\n\nPARAFAC.Initialization.SVD\n\n\nInitialization method for the loading matrices. Can be one of \n{PARAFAC.Initialization.RANDOM, PARAFAC.Initialization.RANDOM_ORTHOGONALIZED, PARAFAC.Initialization.SVD}\n.\n\n\n\n\n\n\n\n\nExample Code\n\n\nint nComponents = ... // Choose a number of components F for the loading matrices\ndouble[][][] data = ... // e.g. load data of shape (I x J x K)\nTensor x = Tensor.create(data);\nPARAFAC pf = new PARAFAC();\npf.setNumComponents(nComponents);\npf.build(x);\nMap<String, Tensor> loads = pf.getLoadingMatrices();\n// loads.get(\"A\") is of shape (I x F)\n// loads.get(\"B\") is of shape (J x F)\n// loads.get(\"C\") is of shape (K x F)",
            "title": "PARAFAC"
        },
        {
            "location": "/algorithms/parafac/#the-parafac-model",
            "text": "PARAFAC  allows the decomposition of three-way data into three loading matrices.",
            "title": "The PARAFAC Model"
        },
        {
            "location": "/algorithms/parafac/#parameters",
            "text": "Parameter Name  Default Value  Description      numComponents  3  Number of components of the loading matrices.    numStarts  1  Number of restarts to find a better minimum. This is only effective if  initMethod=RANDOM .    initMethod  PARAFAC.Initialization.SVD  Initialization method for the loading matrices. Can be one of  {PARAFAC.Initialization.RANDOM, PARAFAC.Initialization.RANDOM_ORTHOGONALIZED, PARAFAC.Initialization.SVD} .",
            "title": "Parameters"
        },
        {
            "location": "/algorithms/parafac/#example-code",
            "text": "int nComponents = ... // Choose a number of components F for the loading matrices\ndouble[][][] data = ... // e.g. load data of shape (I x J x K)\nTensor x = Tensor.create(data);\nPARAFAC pf = new PARAFAC();\npf.setNumComponents(nComponents);\npf.build(x);\nMap<String, Tensor> loads = pf.getLoadingMatrices();\n// loads.get(\"A\") is of shape (I x F)\n// loads.get(\"B\") is of shape (J x F)\n// loads.get(\"C\") is of shape (K x F)",
            "title": "Example Code"
        },
        {
            "location": "/algorithms/npls/",
            "text": "Multilinear Partial Least Squares\n\n\nMultilinear Partial Least Squares\n is a multi-way extension of standard PLS.\nSee also: \nMultiway calibration. Multilinear PLS, Bro 96\n.\n\n\nThis implementation extends the PLS2 algorithm to threeway input and thus works on multitarget \nY\n data.\n\n\nParameters\n\n\n\n\n\n\n\n\nParameter Name\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnumComponents\n\n\n10\n\n\nNumber of components of the loading matrices.\n\n\n\n\n\n\nstandardizeY\n\n\ntrue\n\n\nWhether to standardize the \nY\n target matrix\n\n\n\n\n\n\n\n\nExample Code\n\n\n// Get data\ndouble[][][] xtrain = ... // e.g. load data of shape (I_train x J x K)\ndouble[][][] xtest = ... // e.g. load data of shape (I_test x J x K)\ndouble[][] ytrain = ... // e.g. load data of shape (I_train x M)\ndouble[][] ytest = ... // e.g. load data of shape (I_test x M)\nTensor Xtr = Tensor.create(xtrain);\nTensor Xte = Tensor.create(xtest);\nTensor Ytr = Tensor.create(ytrain);\nTensor Yte = Tensor.create(ytest);\n\n// Setup model\nint nComponents = ... // Choose a number of components F for the loading matrices\nMultiLinearPLS npls = new MultiLinearPLS();\nnpls.setNumComponents(nComponents);\n\n// Build and test model\nnpls.build(Xtr, Ytr);\nTensor Ypred = npls.predict(Yte);\ndouble mse = MathUtils.meanSquaredError(Yte, Ypred);\n\n// Usage as a filter/feature-transformation\nTensor transformedXte = npls.filter(Xte)",
            "title": "Multilinear PLS"
        },
        {
            "location": "/algorithms/npls/#multilinear-partial-least-squares",
            "text": "Multilinear Partial Least Squares  is a multi-way extension of standard PLS.\nSee also:  Multiway calibration. Multilinear PLS, Bro 96 .  This implementation extends the PLS2 algorithm to threeway input and thus works on multitarget  Y  data.",
            "title": "Multilinear Partial Least Squares"
        },
        {
            "location": "/algorithms/npls/#parameters",
            "text": "Parameter Name  Default Value  Description      numComponents  10  Number of components of the loading matrices.    standardizeY  true  Whether to standardize the  Y  target matrix",
            "title": "Parameters"
        },
        {
            "location": "/algorithms/npls/#example-code",
            "text": "// Get data\ndouble[][][] xtrain = ... // e.g. load data of shape (I_train x J x K)\ndouble[][][] xtest = ... // e.g. load data of shape (I_test x J x K)\ndouble[][] ytrain = ... // e.g. load data of shape (I_train x M)\ndouble[][] ytest = ... // e.g. load data of shape (I_test x M)\nTensor Xtr = Tensor.create(xtrain);\nTensor Xte = Tensor.create(xtest);\nTensor Ytr = Tensor.create(ytrain);\nTensor Yte = Tensor.create(ytest);\n\n// Setup model\nint nComponents = ... // Choose a number of components F for the loading matrices\nMultiLinearPLS npls = new MultiLinearPLS();\nnpls.setNumComponents(nComponents);\n\n// Build and test model\nnpls.build(Xtr, Ytr);\nTensor Ypred = npls.predict(Yte);\ndouble mse = MathUtils.meanSquaredError(Yte, Ypred);\n\n// Usage as a filter/feature-transformation\nTensor transformedXte = npls.filter(Xte)",
            "title": "Example Code"
        },
        {
            "location": "/stopping/",
            "text": "Stopping Iterative Algorithms\n\n\nIterative algorithms allow for different stopping criteria such as:\n\n\n\n\nTimeStoppingCriterion\n: Define a maximum time in seconds\n\n\nImprovementStoppingCriterion\n: Stop after improvement between two iterations is below a certain threshold\n\n\nIterationStoppingCriterion\n: Stop after \nmaxIter\n number of iterations\n\n\n\n\nMultiple criteria can be added as follows:\n\n\nPARAFAC alg = new PARAFAC();\nalg.addStoppingCriterion(CriterionUtils.iterations(1000)); // Stop after 1000 iterations\nalg.addStoppingCriterion(CriterionUtils.time(100)); // Stop after 100 seconds\nalg.addStoppingCriterion(CriterionUtils.improvement(10E-10)); // Stop if relative improvement is less than 10E-10\n\n\n\n\nNote\n\n\n\n\nAlgorithm stops if one of the criteria matches \n\n\nAdding a certain criterion multiple times will result in overwriting.",
            "title": "Stopping Criteria"
        },
        {
            "location": "/stopping/#stopping-iterative-algorithms",
            "text": "Iterative algorithms allow for different stopping criteria such as:   TimeStoppingCriterion : Define a maximum time in seconds  ImprovementStoppingCriterion : Stop after improvement between two iterations is below a certain threshold  IterationStoppingCriterion : Stop after  maxIter  number of iterations   Multiple criteria can be added as follows:  PARAFAC alg = new PARAFAC();\nalg.addStoppingCriterion(CriterionUtils.iterations(1000)); // Stop after 1000 iterations\nalg.addStoppingCriterion(CriterionUtils.time(100)); // Stop after 100 seconds\nalg.addStoppingCriterion(CriterionUtils.improvement(10E-10)); // Stop if relative improvement is less than 10E-10",
            "title": "Stopping Iterative Algorithms"
        },
        {
            "location": "/stopping/#note",
            "text": "Algorithm stops if one of the criteria matches   Adding a certain criterion multiple times will result in overwriting.",
            "title": "Note"
        },
        {
            "location": "/data/",
            "text": "Data Tensors\n\n\nThe library provides a \nTensor\n class that can hold data of different orders \n(scalars, vectors, matrices or threeway data). All methods provided by algorithm\napis such as in \nSupervisedAlgorithm\n, \nUnsupervisedAlgorithm\n, \nFilter\n, etc. \naccept \nTensor\n objects as method arguments and return \nTensor\n objects. \n\n\nPrimitive to Tensor\n\n\nTensors can be instantiated with the static \nTensor.create(...)\n method, by passing raw \ndouble\n data:\n\n\n\n\nTensor.create(double data)\n\n\nTensor.create(double[] data)\n\n\nTensor.create(double[][] data)\n\n\nTensor.create(double[][][] data)\n\n\n\n\nTensor to primitive\n\n\nA tensor object \nTensor t\n can be converted back into primitive double arrays with:\n\n\n\n\nt.toScalar() -> double\n\n\nt.toArray1d() -> double[]\n\n\nt.toArray2d() -> double[][]\n\n\nt.toArray3d() -> double[][][]\n\n\n\n\nTensor Order\n\n\nA tensor's order/number of modes can be checked with \nt.order()\n.\n\n\nReading Data\n\n\nThe \nDataReader\n class provides methods to read different file formats.\n\n\nThree-Way Sparse Data\n\n\nDataReader.read3WaySparse(...)\n reads sparse data, giving the indices and the corresponding value, of the following format :\n\n\nx0 y0 z0 value0\nx0 y0 z1 value1\n...\n\n\n\n\nSparse Matrices\n\n\nDataReader.readSparseMatrix(...)\n reads sparse matrices, giving the indices and the corresponding value, of the following format :\n\n\nx0 y0 value0\nx0 y0 value1\n...",
            "title": "Data"
        },
        {
            "location": "/data/#data-tensors",
            "text": "The library provides a  Tensor  class that can hold data of different orders \n(scalars, vectors, matrices or threeway data). All methods provided by algorithm\napis such as in  SupervisedAlgorithm ,  UnsupervisedAlgorithm ,  Filter , etc. \naccept  Tensor  objects as method arguments and return  Tensor  objects.",
            "title": "Data Tensors"
        },
        {
            "location": "/data/#primitive-to-tensor",
            "text": "Tensors can be instantiated with the static  Tensor.create(...)  method, by passing raw  double  data:   Tensor.create(double data)  Tensor.create(double[] data)  Tensor.create(double[][] data)  Tensor.create(double[][][] data)",
            "title": "Primitive to Tensor"
        },
        {
            "location": "/data/#tensor-to-primitive",
            "text": "A tensor object  Tensor t  can be converted back into primitive double arrays with:   t.toScalar() -> double  t.toArray1d() -> double[]  t.toArray2d() -> double[][]  t.toArray3d() -> double[][][]",
            "title": "Tensor to primitive"
        },
        {
            "location": "/data/#tensor-order",
            "text": "A tensor's order/number of modes can be checked with  t.order() .",
            "title": "Tensor Order"
        },
        {
            "location": "/data/#reading-data",
            "text": "The  DataReader  class provides methods to read different file formats.",
            "title": "Reading Data"
        },
        {
            "location": "/data/#three-way-sparse-data",
            "text": "DataReader.read3WaySparse(...)  reads sparse data, giving the indices and the corresponding value, of the following format :  x0 y0 z0 value0\nx0 y0 z1 value1\n...",
            "title": "Three-Way Sparse Data"
        },
        {
            "location": "/data/#sparse-matrices",
            "text": "DataReader.readSparseMatrix(...)  reads sparse matrices, giving the indices and the corresponding value, of the following format :  x0 y0 value0\nx0 y0 value1\n...",
            "title": "Sparse Matrices"
        }
    ]
}