{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Multiway Algorithms Java library of multi-way algorithms. Algorithms Available algorithms: Multi-linear PLS Non-Negative Tensor Factorization (NTF) PARAFAC Sequentially Orthogonalized Multilinear PLS (SONPLS) TwoWayPCA Maven Add the following dependency in your pom.xml : <dependency> <groupId>nz.ac.waikato.cms.adams</groupId> <artifactId>multiway-algorithms</artifactId> <version>0.0.12</version> </dependency>","title":"Home"},{"location":"#multiway-algorithms","text":"Java library of multi-way algorithms.","title":"Multiway Algorithms"},{"location":"#algorithms","text":"Available algorithms: Multi-linear PLS Non-Negative Tensor Factorization (NTF) PARAFAC Sequentially Orthogonalized Multilinear PLS (SONPLS) TwoWayPCA","title":"Algorithms"},{"location":"#maven","text":"Add the following dependency in your pom.xml : <dependency> <groupId>nz.ac.waikato.cms.adams</groupId> <artifactId>multiway-algorithms</artifactId> <version>0.0.12</version> </dependency>","title":"Maven"},{"location":"data/","text":"Data Tensors The library provides a Tensor class that can hold data of different orders (scalars, vectors, matrices or threeway data). All methods provided by algorithm apis such as in SupervisedAlgorithm , UnsupervisedAlgorithm , Filter , etc. accept Tensor objects as method arguments and return Tensor objects. Primitive to Tensor Tensors can be instantiated with the static Tensor.create(...) method, by passing raw double data: Tensor.create(double data) Tensor.create(double[] data) Tensor.create(double[][] data) Tensor.create(double[][][] data) Tensor to primitive A tensor object Tensor t can be converted back into primitive double arrays with: t.toScalar() -> double t.toArray1d() -> double[] t.toArray2d() -> double[][] t.toArray3d() -> double[][][] Tensor Order A tensor's order/number of modes can be checked with t.order() . Reading Data The DataReader class provides methods to read different file formats. Three-Way Sparse Data DataReader.read3WaySparse(...) reads sparse data, giving the indices and the corresponding value, of the following format : x0 y0 z0 value0 x0 y0 z1 value1 ... Sparse Matrices DataReader.readSparseMatrix(...) reads sparse matrices, giving the indices and the corresponding value, of the following format : x0 y0 value0 x0 y0 value1 ... Multiple CSV Files DataReader.read3WayMultiCsv(...) reads three-way tensors which have one mode distributed across multiple files. That is, a I x J x K tensor could have K files with the name data{k}.csv (with k in 1..k ) and each file contains a dense I x J matrix.","title":"Data"},{"location":"data/#data-tensors","text":"The library provides a Tensor class that can hold data of different orders (scalars, vectors, matrices or threeway data). All methods provided by algorithm apis such as in SupervisedAlgorithm , UnsupervisedAlgorithm , Filter , etc. accept Tensor objects as method arguments and return Tensor objects.","title":"Data Tensors"},{"location":"data/#primitive-to-tensor","text":"Tensors can be instantiated with the static Tensor.create(...) method, by passing raw double data: Tensor.create(double data) Tensor.create(double[] data) Tensor.create(double[][] data) Tensor.create(double[][][] data)","title":"Primitive to Tensor"},{"location":"data/#tensor-to-primitive","text":"A tensor object Tensor t can be converted back into primitive double arrays with: t.toScalar() -> double t.toArray1d() -> double[] t.toArray2d() -> double[][] t.toArray3d() -> double[][][]","title":"Tensor to primitive"},{"location":"data/#tensor-order","text":"A tensor's order/number of modes can be checked with t.order() .","title":"Tensor Order"},{"location":"data/#reading-data","text":"The DataReader class provides methods to read different file formats.","title":"Reading Data"},{"location":"data/#three-way-sparse-data","text":"DataReader.read3WaySparse(...) reads sparse data, giving the indices and the corresponding value, of the following format : x0 y0 z0 value0 x0 y0 z1 value1 ...","title":"Three-Way Sparse Data"},{"location":"data/#sparse-matrices","text":"DataReader.readSparseMatrix(...) reads sparse matrices, giving the indices and the corresponding value, of the following format : x0 y0 value0 x0 y0 value1 ...","title":"Sparse Matrices"},{"location":"data/#multiple-csv-files","text":"DataReader.read3WayMultiCsv(...) reads three-way tensors which have one mode distributed across multiple files. That is, a I x J x K tensor could have K files with the name data{k}.csv (with k in 1..k ) and each file contains a dense I x J matrix.","title":"Multiple CSV Files"},{"location":"stopping/","text":"Stopping Iterative Algorithms Iterative algorithms allow for different stopping criteria such as: TimeStoppingCriterion : Define a maximum time in seconds ImprovementStoppingCriterion : Stop after improvement between two iterations is below a certain threshold IterationStoppingCriterion : Stop after maxIter number of iterations Multiple criteria can be added as follows: PARAFAC alg = new PARAFAC(); alg.addStoppingCriterion(CriterionUtils.iterations(1000)); // Stop after 1000 iterations alg.addStoppingCriterion(CriterionUtils.time(100)); // Stop after 100 seconds alg.addStoppingCriterion(CriterionUtils.improvement(10E-10)); // Stop if relative improvement is less than 10E-10 Note Algorithm stops if one of the criteria matches Adding a certain criterion multiple times will result in overwriting.","title":"Stopping Criteria"},{"location":"stopping/#stopping-iterative-algorithms","text":"Iterative algorithms allow for different stopping criteria such as: TimeStoppingCriterion : Define a maximum time in seconds ImprovementStoppingCriterion : Stop after improvement between two iterations is below a certain threshold IterationStoppingCriterion : Stop after maxIter number of iterations Multiple criteria can be added as follows: PARAFAC alg = new PARAFAC(); alg.addStoppingCriterion(CriterionUtils.iterations(1000)); // Stop after 1000 iterations alg.addStoppingCriterion(CriterionUtils.time(100)); // Stop after 100 seconds alg.addStoppingCriterion(CriterionUtils.improvement(10E-10)); // Stop if relative improvement is less than 10E-10","title":"Stopping Iterative Algorithms"},{"location":"stopping/#note","text":"Algorithm stops if one of the criteria matches Adding a certain criterion multiple times will result in overwriting.","title":"Note"},{"location":"algorithms/npls/","text":"Multilinear Partial Least Squares Multilinear Partial Least Squares is a multi-way extension of standard PLS. See also: Multiway calibration. Multilinear PLS, Bro 96 . This implementation extends the PLS2 algorithm to threeway input and thus works on multitarget Y data. Parameters Parameter Name Default Value Description numComponents 10 Number of components of the loading matrices. standardizeY true Whether to standardize the Y target matrix Example Code // Get data double[][][] xtrain = ... // e.g. load data of shape (I_train x J x K) double[][][] xtest = ... // e.g. load data of shape (I_test x J x K) double[][] ytrain = ... // e.g. load data of shape (I_train x M) double[][] ytest = ... // e.g. load data of shape (I_test x M) Tensor Xtr = Tensor.create(xtrain); Tensor Xte = Tensor.create(xtest); Tensor Ytr = Tensor.create(ytrain); Tensor Yte = Tensor.create(ytest); // Setup model int nComponents = ... // Choose a number of components F for the loading matrices MultiLinearPLS npls = new MultiLinearPLS(); npls.setNumComponents(nComponents); // Build and test model npls.build(Xtr, Ytr); Tensor Ypred = npls.predict(Yte); double mse = MathUtils.meanSquaredError(Yte, Ypred); // Usage as a filter/feature-transformation Tensor transformedXte = npls.filter(Xte)","title":"Multilinear PLS"},{"location":"algorithms/npls/#multilinear-partial-least-squares","text":"Multilinear Partial Least Squares is a multi-way extension of standard PLS. See also: Multiway calibration. Multilinear PLS, Bro 96 . This implementation extends the PLS2 algorithm to threeway input and thus works on multitarget Y data.","title":"Multilinear Partial Least Squares"},{"location":"algorithms/npls/#parameters","text":"Parameter Name Default Value Description numComponents 10 Number of components of the loading matrices. standardizeY true Whether to standardize the Y target matrix","title":"Parameters"},{"location":"algorithms/npls/#example-code","text":"// Get data double[][][] xtrain = ... // e.g. load data of shape (I_train x J x K) double[][][] xtest = ... // e.g. load data of shape (I_test x J x K) double[][] ytrain = ... // e.g. load data of shape (I_train x M) double[][] ytest = ... // e.g. load data of shape (I_test x M) Tensor Xtr = Tensor.create(xtrain); Tensor Xte = Tensor.create(xtest); Tensor Ytr = Tensor.create(ytrain); Tensor Yte = Tensor.create(ytest); // Setup model int nComponents = ... // Choose a number of components F for the loading matrices MultiLinearPLS npls = new MultiLinearPLS(); npls.setNumComponents(nComponents); // Build and test model npls.build(Xtr, Ytr); Tensor Ypred = npls.predict(Yte); double mse = MathUtils.meanSquaredError(Yte, Ypred); // Usage as a filter/feature-transformation Tensor transformedXte = npls.filter(Xte)","title":"Example Code"},{"location":"algorithms/ntf/","text":"Non-Negative Tensor Factorization Non-Negative Tensor Factorization is a multi-way extension of standard Non-Negative Matrix Factorization. See also: Non-negative tensor factorization with applications to statistics and computer vision . Parameters Parameter Name Default Value Description numComponents 10 Number of components of the loading matrices. gradientUpateType GRADIENT_UPDATE_TYPE.NORMALIZED_UPDATE Update method for the decomposed values. Can be one of GRADIENT_UPDATE_TYPE.{NORMALIZED_UPDATE, STEP_UPDATE_CUSTOM,ITERATION_UPDATE_CUSTOM} . updater none Can be an implementation of org.nd4j.linalg.learning.config.IUpdater . Only used of gradientUpdateType is not GRADIENT_UPDATE_TYPE.NORMALIZED_UPDATE Example Code // Get data Tensor X = Tensor.create(xdata); // Setup model int nComponents = ... // Choose a number of components F for the loading matrices NTF ntf = new NTF(); ntf.setNumComponents(nComponents); // Build model ntf.build(X); Tensor[] decomposition = ntf.getDecomposition(); // Get #numModes matrices that represent the tensor decomposition","title":"Non-Negative Tensor Factorization"},{"location":"algorithms/ntf/#non-negative-tensor-factorization","text":"Non-Negative Tensor Factorization is a multi-way extension of standard Non-Negative Matrix Factorization. See also: Non-negative tensor factorization with applications to statistics and computer vision .","title":"Non-Negative Tensor Factorization"},{"location":"algorithms/ntf/#parameters","text":"Parameter Name Default Value Description numComponents 10 Number of components of the loading matrices. gradientUpateType GRADIENT_UPDATE_TYPE.NORMALIZED_UPDATE Update method for the decomposed values. Can be one of GRADIENT_UPDATE_TYPE.{NORMALIZED_UPDATE, STEP_UPDATE_CUSTOM,ITERATION_UPDATE_CUSTOM} . updater none Can be an implementation of org.nd4j.linalg.learning.config.IUpdater . Only used of gradientUpdateType is not GRADIENT_UPDATE_TYPE.NORMALIZED_UPDATE","title":"Parameters"},{"location":"algorithms/ntf/#example-code","text":"// Get data Tensor X = Tensor.create(xdata); // Setup model int nComponents = ... // Choose a number of components F for the loading matrices NTF ntf = new NTF(); ntf.setNumComponents(nComponents); // Build model ntf.build(X); Tensor[] decomposition = ntf.getDecomposition(); // Get #numModes matrices that represent the tensor decomposition","title":"Example Code"},{"location":"algorithms/parafac/","text":"The PARAFAC Model PARAFAC allows the decomposition of three-way data into three loading matrices. Parameters Parameter Name Default Value Description numComponents 3 Number of components of the loading matrices. numStarts 1 Number of restarts to find a better minimum. This is only effective if initMethod=RANDOM . initMethod PARAFAC.Initialization.SVD Initialization method for the loading matrices. Can be one of {PARAFAC.Initialization.RANDOM, PARAFAC.Initialization.RANDOM_ORTHOGONALIZED, PARAFAC.Initialization.SVD} . Example Code int nComponents = ... // Choose a number of components F for the loading matrices double[][][] data = ... // e.g. load data of shape (I x J x K) Tensor X = Tensor.create(data); PARAFAC pf = new PARAFAC(); pf.setNumComponents(nComponents); pf.build(X); Map<String, Tensor> loads = pf.getLoadingMatrices(); // loads.get(\"A\") is of shape (I x F) // loads.get(\"B\") is of shape (J x F) // loads.get(\"C\") is of shape (K x F) Generate Scores using Loadings of a Calibrated Model It is possible to generate scores for new data having the same dimension in the second and third mode based on an already calibrated PARAFAC model. See also: Multi\u2010way prediction in the presence of uncalibrated interferents . // Data Tensor Xtrain = ... // Data of shape (I_1 x J x K) Tensor Xnew = ... // Data of shape (I_2 x J x K) // Model setup PARAFAC pf = new PARAFAC() pf.setNumComponents(F); ... // Generate new scores of shape (I_2 x F) Tensor scores = pf.filter(Xnew);","title":"PARAFAC"},{"location":"algorithms/parafac/#the-parafac-model","text":"PARAFAC allows the decomposition of three-way data into three loading matrices.","title":"The PARAFAC Model"},{"location":"algorithms/parafac/#parameters","text":"Parameter Name Default Value Description numComponents 3 Number of components of the loading matrices. numStarts 1 Number of restarts to find a better minimum. This is only effective if initMethod=RANDOM . initMethod PARAFAC.Initialization.SVD Initialization method for the loading matrices. Can be one of {PARAFAC.Initialization.RANDOM, PARAFAC.Initialization.RANDOM_ORTHOGONALIZED, PARAFAC.Initialization.SVD} .","title":"Parameters"},{"location":"algorithms/parafac/#example-code","text":"int nComponents = ... // Choose a number of components F for the loading matrices double[][][] data = ... // e.g. load data of shape (I x J x K) Tensor X = Tensor.create(data); PARAFAC pf = new PARAFAC(); pf.setNumComponents(nComponents); pf.build(X); Map<String, Tensor> loads = pf.getLoadingMatrices(); // loads.get(\"A\") is of shape (I x F) // loads.get(\"B\") is of shape (J x F) // loads.get(\"C\") is of shape (K x F)","title":"Example Code"},{"location":"algorithms/parafac/#generate-scores-using-loadings-of-a-calibrated-model","text":"It is possible to generate scores for new data having the same dimension in the second and third mode based on an already calibrated PARAFAC model. See also: Multi\u2010way prediction in the presence of uncalibrated interferents . // Data Tensor Xtrain = ... // Data of shape (I_1 x J x K) Tensor Xnew = ... // Data of shape (I_2 x J x K) // Model setup PARAFAC pf = new PARAFAC() pf.setNumComponents(F); ... // Generate new scores of shape (I_2 x F) Tensor scores = pf.filter(Xnew);","title":"Generate Scores using Loadings of a Calibrated Model"}]}